import { BlogLayout } from "../../components/layout/BlogLayout";

# This Month I Learned: Here's what I learned in January

## Remix

I started the new year off with learning a new web framework. Remix has been a blast to learn so far and while it doesn't have _all_
of the bells and whistles that Next.js has you can still do the same amount of things if not more. Some of the cool things I've learned
were about forms and some of the unknown functionalities about them, more about how routing works, and I dove a little bit into remix-auth
which makes it super easy for you to handle auth.

Handling any type of form in Remix is super easy, you can either use the html `form` tag or use the `Form` component that Remix
provides. Here's what a simple form would look like.

```html
<form method="post">
  <label for="fruit">What's your favorite fruit?</label>
  <input type="text" name="fruit" id="fruit" />
  <button type="submit">Post fruit</button>
</form>
```

This, along with the [action function](https://remix.run/docs/en/v1/guides/data-writes#html-form-post) is how you would send data to your backend. Simple, eh? Remix takes away all of that extra setup you would
need with a normal react application and makes it simple. This is how it was done back in the day!

Setting up auth is also just as easy, just set up your session storage and make a few helper functions and you're on your way. The alternative would be to use the remix-auth package that does all of that work for you so you
can focus on building your application. Again, look at how simple some of the set up is for creating an auth system.

```javascript
// session.server.ts
import { createCookieSessionStorage } from "remix";

export let sessionStorage = createCookieSessionStorage({
  cookie: {
    name: "__session",
    secrets: ["mysecret"],
    path: "/",
    sameSite: "lax",
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
  },
});

export let { commitSession, destroySession, getSession } = sessionStorage;
```

```javascript
// app/routes/login.tsx
export let action: ActionFunction = async ({ request }) => {
  let body = await request.formData();
  let username = body.get("username") as string;
  let password = body.get("password") as string;

  let errors: LoginErrors = {};
  if (!username) errors.username = true;
  if (!password) errors.password = true;

  if (Object.keys(errors).length) {
    return errors;
  }

  let session = await getSession(request.headers.get("Cookie"));

  session.set("user", username);

  return redirect("/users", {
    headers: {
      "Set-Cookie": await commitSession(session),
    },
  });
};

export default function Login() {
  let errors = useActionData<LoginErrors>();
  return (
    <div style={{ display: "flex", justifyContent: "center", marginTop: 300 }}>
      <Paper sx={{ maxWidth: 500, flex: 1 }} padding={10} withBorder>
        <Form method="post">
          {errors?.username && (
            <Text color="red" aria-live="assertive" size="sm">
              Username is required
            </Text>
          )}
          <TextInput
            label="Username"
            required
            name="username"
            aria-required="true"
            sx={{ marginBottom: 10 }}
            description="Use any username and password"
          />
          {errors?.password && (
            <Text color="red" aria-live="assertive" size="sm">
              Password is required
            </Text>
          )}
          <PasswordInput
            label="Password"
            name="password"
            required
            aria-required="true"
            sx={{ marginBottom: 10 }}
          />
          <Button type="submit">Log in</Button>
        </Form>
      </Paper>
    </div>
  );
}
```

That's it, that's literally it. Remix is so so _soooo_ simple to get started with and it teaches you a lot about the very basic stuff about the web you probably
might have not known about. I learned this from the discord but I did not know buttons and inputs had a `form` attribute, you can give a form an ID and associate that input
or button with that form while _outside_ of the actual form and it'll still work. Here's what I'm talking about.

```html
<form method="post" id="form1">
  <label for="fname">First name:</label>
  <input type="text" id="fname" name="fname" /><br /><br />
  <input type="submit" value="Submit" />
</form>

<label for="lname">Last name:</label>
<input type="text" id="lname" name="lname" form="form1" />
```

The `lname` input is outside of the form but still associated with it because it has the `form="form1"` attribute ðŸ¤¯. I also learned that you can
disable a group of inputs inside of a fieldset by just adding the `disabled` attribute to the fieldset. This is all already part of the web, not Remix related! This is why I love it so much. Helping
developers do better by using the tools that are already available to them instead of re-inventing the wheel.

The Remix team is just getting started, I honestly believe that Remix will be one of the default ways to build web applications going forward and definitely
deserves all the praise it gets. If you haven't already played around with it I highly reccommend it.

## Learning Golang with TDD

Learning Golang has been something I've been doing on and off for a while now but never stuck with because I couldn't find a viable project to practice with. I definitely
do want to use this language more this year but I absolutely forgot a lot of what I learned so I decided to tackle it from a different angle, TDD. Test Driven Development
is something I've never done before but have heard about. I can see why it's useful as it gets you thinking about writing your code in a way that's testable and not
brittle.

I went through [this book on learning go with tests](https://quii.gitbook.io/learn-go-with-tests/) and got through about 70% of it before I understood the pattern and felt
comfortable enough with writing code on my own. The thing that is repeated a lot in this book is "red, green, refactor" which means write the test first, watch it fail and then write enough code to make it
pass. Once your tests are passing and are tested against a few scenarios you would then refactor to make it more readable. I skipped the refactor step and just added TODO comments and then just never
went back to refactor but that will be our little secret.

I did learn a lot going through that book but I feel like with anything I need a ton more practice before I'm writing anything production level.

## Conclusion

January wasn't really jam packed but I wanted to keep it kind of light. I'm going to continue going forward with learning about Remix and golang but for this next month
I really want to double down on learning CSS.

export default ({ children }) => (
  <BlogLayout meta={metadata}>{children}</BlogLayout>
);

export const metadata = {
  title: "This Month I Learned: Here's what I learned in January",
  description:
    "Starting off my learning blog series with things I've learned in January",
  date: "2022-02-01",
  tags: ["Remix", "Golang", "TDD"],
};
